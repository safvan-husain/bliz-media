---
interface Segment {
    text: string;
    class?: string;
    className?: string;
}

interface Props {
    as?: string;
    className?: string;
    text?: string;
    segments?: Segment[];
    delayStepMs?: number;
    baseDelayMs?: number;
}

const {
    as = "h2",
    className = "",
    text,
    segments = [],
    delayStepMs = 45,
    baseDelayMs = 0,
} = Astro.props;

const normalizedSegments: Segment[] =
    segments.length > 0 ? segments : text ? [{ text }] : [];

const fullText = normalizedSegments.map((segment) => segment.text).join("");
const splitWithWhitespace = (value: string) => value.split(/(\s+)/);
const totalWords = normalizedSegments.reduce((count, segment) => {
    return (
        count +
        splitWithWhitespace(segment.text).filter(
            (part) => part.length > 0 && !/^\s+$/.test(part),
        ).length
    );
}, 0);

const segmentMap: {
    className: string;
    parts: {
        text: string;
        index: number;
        curve: number;
        isWhitespace: boolean;
    }[];
}[] = [];
let wordIndex = 0;

for (const segment of normalizedSegments) {
    const parts: {
        text: string;
        index: number;
        curve: number;
        isWhitespace: boolean;
    }[] = [];

    for (const part of splitWithWhitespace(segment.text)) {
        if (!part) {
            continue;
        }

        const isWhitespace = /^\s+$/.test(part);
        const progress =
            !isWhitespace && totalWords > 1 ? wordIndex / (totalWords - 1) : 0;
        const curve = Math.round(12 + progress * progress * 20);

        parts.push({
            text: part,
            index: wordIndex,
            curve,
            isWhitespace,
        });

        if (!isWhitespace) {
            wordIndex += 1;
        }
    }

    segmentMap.push({
        className: segment.className ?? segment.class ?? "",
        parts,
    });
}

const Tag = as;
---

<Tag
    class={`curve-reveal-text ${className}`}
    aria-label={fullText}
    data-curve-reveal
    style={`--curve-delay-step: ${delayStepMs}ms; --curve-base-delay: ${baseDelayMs}ms;`}
>
    {
        segmentMap.map((segment) => (
            <span
                class={`curve-reveal-segment ${segment.className}`}
                aria-hidden="true"
            >
                {segment.parts.map((entry) =>
                    entry.isWhitespace ? (
                        <span aria-hidden="true">{entry.text}</span>
                    ) : (
                        <span
                            class="curve-reveal-part"
                            aria-hidden="true"
                            style={`--part-index: ${entry.index}; --part-curve: ${entry.curve}px;`}
                        >
                            {entry.text}
                        </span>
                    ),
                )}
            </span>
        ))
    }
</Tag>

<script>
    if (typeof window !== "undefined") {
        const revealElements = document.querySelectorAll("[data-curve-reveal]");

        if (revealElements.length > 0) {
            const observer = new IntersectionObserver(
                (entries, obs) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                            entry.target.setAttribute(
                                "data-reveal-state",
                                "visible",
                            );
                            obs.unobserve(entry.target);
                        }
                    });
                },
                { threshold: 0.2, rootMargin: "0px 0px -8% 0px" },
            );

            revealElements.forEach((element) => {
                if (element.getAttribute("data-reveal-state") !== "visible") {
                    element.setAttribute("data-reveal-state", "pending");
                    observer.observe(element);
                }
            });
        }
    }
</script>
