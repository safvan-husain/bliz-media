---
interface Segment {
    text: string;
    class?: string;
}

interface Props {
    as?: string;
    className?: string;
    text?: string;
    segments?: Segment[];
    delayStepMs?: number;
    baseDelayMs?: number;
}

const {
    as = "h2",
    className = "",
    text,
    segments = [],
    delayStepMs = 24,
    baseDelayMs = 0,
} = Astro.props;

const normalizedSegments: Segment[] =
    segments.length > 0 ? segments : text ? [{ text }] : [];

const fullText = normalizedSegments.map((segment) => segment.text).join("");
const splitWithWhitespace = (value: string) => value.split(/(\s+)/);
const totalWords = normalizedSegments.reduce((count, segment) => {
    return (
        count +
        splitWithWhitespace(segment.text).filter(
            (part) => part.length > 0 && !/^\s+$/.test(part),
        ).length
    );
}, 0);

const partMap: {
    text: string;
    className: string;
    index: number;
    curve: number;
    isWhitespace: boolean;
}[] = [];
let wordIndex = 0;

for (const segment of normalizedSegments) {
    for (const part of splitWithWhitespace(segment.text)) {
        if (!part) {
            continue;
        }

        const isWhitespace = /^\s+$/.test(part);
        const progress =
            !isWhitespace && totalWords > 1 ? wordIndex / (totalWords - 1) : 0;
        const curve = Math.round(10 + progress * progress * 22);

        partMap.push({
            text: part,
            className: segment.class ?? "",
            index: wordIndex,
            curve,
            isWhitespace,
        });

        if (!isWhitespace) {
            wordIndex += 1;
        }
    }
}

const Tag = as;
---

<Tag
    class={`curve-reveal-text ${className}`}
    aria-label={fullText}
    data-curve-reveal
    style={`--curve-delay-step: ${delayStepMs}ms; --curve-base-delay: ${baseDelayMs}ms;`}
>
    {
        partMap.map((entry) =>
            entry.isWhitespace ? (
                <span aria-hidden="true">{entry.text}</span>
            ) : (
                <span
                    class={`curve-reveal-part ${entry.className}`}
                    aria-hidden="true"
                    style={`--part-index: ${entry.index}; --part-curve: ${entry.curve}px;`}
                >
                    {entry.text}
                </span>
            ),
        )
    }
</Tag>

<script>
    if (typeof window !== "undefined") {
        const revealElements = document.querySelectorAll("[data-curve-reveal]");

        if (revealElements.length > 0) {
            const observer = new IntersectionObserver(
                (entries, obs) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                            entry.target.setAttribute(
                                "data-reveal-state",
                                "visible",
                            );
                            obs.unobserve(entry.target);
                        }
                    });
                },
                { threshold: 0.2, rootMargin: "0px 0px -8% 0px" },
            );

            revealElements.forEach((element) => {
                if (element.getAttribute("data-reveal-state") !== "visible") {
                    element.setAttribute("data-reveal-state", "pending");
                    observer.observe(element);
                }
            });
        }
    }
</script>
